bool mp4_decoder_impl::process_superframe (uint8_t frameBytes [])
        {
            int16_t		i, j, k;
            uint8_t   rsIn [120];
            uint8_t   rsOut [110];
            uint8_t   dacRate;
            uint8_t   sbrFlag;
            uint8_t   aacChannelMode;
            uint8_t   psFlag;
            uint16_t  mpegSurround;
            uint8_t   num_aus;
            /**
                       * apply reed-solomon error repar
                       * OK, what we now have is a vector with RSDims * 120 uint8_t's
                       * the superframe, containing parity bytes for error repair
                       * take into account the interleaving that is applied.
                       */
            for (j = 0; j < d_bit_rate_n; j++) {
                int16_t ler = 0;
                for (k = 0; k < 120; k++)
                    rsIn[k] = frameBytes[j + k * d_bit_rate_n];
                ler = my_rsDecoder.dec(rsIn, rsOut, 135);
                if (ler < 0)
                    return false;
                for (k = 0; k < 110; k++)
                    outVector[j + k * d_bit_rate_n] = rsOut[k];
            }

//	bits 0 .. 15 is firecode
//	bit 16 is unused
            dacRate = (outVector[2] >> 6) & 01;    // bit 17
            sbrFlag = (outVector[2] >> 5) & 01;    // bit 18
            aacChannelMode = (outVector[2] >> 4) & 01;    // bit 19
            psFlag = (outVector[2] >> 3) & 01;    // bit 20
            mpegSurround = (outVector[2] & 07);        // bits 21 .. 23

            switch (2 * dacRate + sbrFlag) {
                default:        // cannot happen
                case 0:
                    num_aus = 4;
                    au_start[0] = 8;
                    au_start[1] = outVector[3] * 16 + (outVector[4] >> 4);
                    au_start[2] = (outVector[4] & 0xf) * 256 +
                                  outVector[5];
                    au_start[3] = outVector[6] * 16 +
                                  (outVector[7] >> 4);
                    au_start[4] = 110 * (bitRate / 8);
                    break;
//
                case 1:
                    num_aus = 2;
                    au_start[0] = 5;
                    au_start[1] = outVector[3] * 16 +
                                  (outVector[4] >> 4);
                    au_start[2] = 110 * (bitRate / 8);
                    break;
//
                case 2:
                    num_aus = 6;
                    au_start[0] = 11;
                    au_start[1] = outVector[3] * 16 + (outVector[4] >> 4);
                    au_start[2] = (outVector[4] & 0xf) * 256 + outVector[5];
                    au_start[3] = outVector[6] * 16 + (outVector[7] >> 4);
                    au_start[4] = (outVector[7] & 0xf) * 256 + outVector[8];
                    au_start[5] = outVector[9] * 16 + (outVector[10] >> 4);
                    au_start[6] = 110 * (bitRate / 8);
                    break;
//
                case 3:
                    num_aus = 3;
                    au_start[0] = 6;
                    au_start[1] = outVector[3] * 16 + (outVector[4] >> 4);
                    au_start[2] = (outVector[4] & 0xf) * 256 + outVector[5];
                    au_start[3] = 110 * (bitRate / 8);
                    break;
            }

/**
  *	OK, the result is N * 110 * 8 bits (still single bit per byte!!!)
  *	extract the AU's, and prepare a buffer,  with the sufficient
  *	lengthy for conversion to PCM samples
  */
            for (i = 0; i < num_aus; i ++) {
                int16_t	aac_frame_length;

// sanity check
                if (au_start [i + 1] < au_start [i]) {
                    GR_LOG_ERROR(d_logger, format("AU address: %d %d (%d)") %au_start [i] %au_start[i + 1] %i);
                    //	should not happen, all errors were corrected
                    return false;
                }

                aac_frame_length = au_start [i + 1] - au_start [i] - 2;
//sanity check
                if ((aac_frame_length >=  960) || (aac_frame_length < 0)) {
                    GR_LOG_ERROR(d_logger, format("aac_frame_length = %d") %aac_frame_length);
                    return false;
                }

// CRC check
                if (check_crc_bytes (&outVector [au_start [i]],
                                     aac_frame_length)) {
                    bool err;
                    handle_aacFrame (&outVector [au_start [i]],
                                     aac_frame_length,
                                     dacRate,
                                     sbrFlag,
                                     mpegSurround,
                                     aacChannelMode,
                                     &err);
                    //emit isStereo (aacChannelMode);
                    /*if (err)
                        aacErrors ++;
                    if (++aacFrames > 25) {
                        show_aacErrors (aacErrors);
                        aacErrors	= 0;
                        aacFrames	= 0;
                    }*/
                }
                else {
                    GR_LOG_DEBUG(d_logger, format("CRC failure with dab+ frame %d (%d)") %i %num_aus);
                }
            }
            return true;
        }


        void	mp4_decoder_impl::handle_aacFrame (uint8_t *v,
                                               int16_t frame_length,
                                               uint8_t	dacRate,
                                               uint8_t	sbrFlag,
                                               uint8_t	mpegSurround,
                                               uint8_t	aacChannelMode,
                                               bool	*error)
        {
            uint8_t theAudioUnit [2 * 960 + 10];	// sure, large enough

            memcpy (theAudioUnit, v, frame_length);
            memset (&theAudioUnit [frame_length], 0, 10);

            if (((theAudioUnit [0] >> 5) & 07) == 4) {
                int16_t count = theAudioUnit [1];
                uint8_t buffer [count];
                memcpy (buffer, &theAudioUnit [2], count);
                uint8_t L0	= buffer [count - 1];
                uint8_t L1	= buffer [count - 2];
                //my_padhandler. processPAD (buffer, count - 3, L1, L0);
            }

            int tmp = MP42PCM (dacRate,
                                           sbrFlag,
                                           mpegSurround,
                                           aacChannelMode,
                                           theAudioUnit,
                                           frame_length); //TODO: include aacDecoder with MP42PCM
            *error	= (tmp == 0);
        }

        int mp4_decoder_impl::faad_decoder_get_aac_channel_configuration (int16_t m_mpeg_surround_config,
                                           uint8_t aacChannelMode) {

            switch(m_mpeg_surround_config) {
                case 0:     // no surround
                    return aacChannelMode ? 2 : 1;
                case 1:     // 5.1
                    return 6;
                case 2:     // 7.1
                    return 7;
                default:
                    return -1;
            }
        }

        bool    mp4_decoder_impl::faad_decoder_initialize (uint8_t dacRate, uint8_t sbrFlag, int16_t mpegSurround, uint8_t aacChannelMode) {
            long unsigned int sample_rate;
            uint8_t channels;
/* AudioSpecificConfig structure (the only way to select 960 transform here!)
 *
 *  00010 = AudioObjectType 2 (AAC LC)
 *  xxxx  = (core) sample rate index
 *  xxxx  = (core) channel config
 *  100   = GASpecificConfig with 960 transform
 *
 * SBR: implicit signaling sufficient - libfaad2
 * automatically assumes SBR on sample rates <= 24 kHz
 * => explicit signaling works, too, but is not necessary here
 *
 * PS:  implicit signaling sufficient - libfaad2
 * therefore always uses stereo output (if PS support was enabled)
 * => explicit signaling not possible, as libfaad2 does not
 * support AudioObjectType 29 (PS)
 */

            int core_sr_index =
                    dacRate ? (sbrFlag ? 6 : 3) :
                    (sbrFlag ? 8 : 5);   // 24/48/16/32 kHz
            int core_ch_config = get_aac_channel_configuration (mpegSurround,
                                                                aacChannelMode);
            if (core_ch_config == -1) {
                GR_LOG_DEBUG(d_logger, format("Unrecognized mpeg surround config (ignored): %d") %mpegSurround);
                return false;
            }

            uint8_t asc[2];
            asc[0] = 0b00010 << 3 | core_sr_index >> 1;
            asc[1] = (core_sr_index & 0x01) << 7 | core_ch_config << 3 | 0b100;
            long int init_result = NeAACDecInit2 (aacHandle,
                                                  asc,
                                                  sizeof (asc),
                                                  &sample_rate,
                                                  &channels); //TODO: include neaacdec library
            if (init_result != 0) {
/*      If some error initializing occured, skip the file */
                GR_LOG_DEBUG(d_logger, format("Error initializing decoder library: %s") %NeAACDecGetErrorMessage (-init_result));
                /*printf ("Error initializing decoder library: %s\n",
                        NeAACDecGetErrorMessage (-init_result));*/
                NeAACDecClose (aacHandle);
                return false;
            }
            return true;
        }

        int16_t mp4_decoder_impl::faad_decoder_MP42PCM (uint8_t   dacRate,
                                      uint8_t   sbrFlag,
                                      int16_t   mpegSurround,
                                      uint8_t   aacChannelMode,
                                      uint8_t   buffer [],
                                      int16_t   bufferLength) {
            int16_t samples;
            long unsigned int sampleRate;
            int16_t *outBuffer;
            NeAACDecFrameInfo hInfo;
            uint8_t dummy   [10000];
            uint8_t channels;

            if (!aacInitialized) {
                if (!initialize (dacRate, sbrFlag, mpegSurround, aacChannelMode))
                    return 0;
                aacInitialized = true;
            }

            outBuffer = (int16_t *)NeAACDecDecode (aacHandle,
                                                   &hInfo, buffer, bufferLength);
            //sampleRate      = hInfo. samplerate;

            sampleRate      = hInfo. samplerate;
            samples         = hInfo. samples;
            if ((sampleRate == 24000) ||
                (sampleRate == 32000) ||
                (sampleRate == 48000) ||
                (sampleRate !=  (long unsigned)baudRate))
                baudRate = sampleRate;

//      fprintf (stderr, "bytes consumed %d\n", (int)(hInfo. bytesconsumed));
//      fprintf (stderr, "samplerate = %d, samples = %d, channels = %d, error = %d, sbr = %d\n", sampleRate, samples,
//               hInfo. channels,
//               hInfo. error,
//               hInfo. sbr);
//      fprintf (stderr, "header = %d\n", hInfo. header_type);
            channels        = hInfo. channels;
            if (hInfo. error != 0) {
                GR_LOG_ERROR(d_logger, format("Warning: %s") %faacDecGetErrorMessage (hInfo. error));
                /*fprintf (stderr, "Warning: %s\n",
                         faacDecGetErrorMessage (hInfo. error));*/
                return 0;
            }

            if (channels == 2) {
                audioBuffer  -> putDataIntoBuffer (outBuffer, samples); //TODO: write in out buffer instead
                /*if (audioBuffer -> GetRingBufferReadAvailable () > sampleRate / 8)
                    newAudio (sampleRate);*/ //TODO: how to deal with stereo???
            }
            else
            if (channels == 1) {
                int16_t *buffer = (int16_t *)alloca (2 * samples); //TODO: alloca???
                int16_t i;
                for (i = 0; i < samples; i ++) {
                    buffer [2 * i]    = ((int16_t *)outBuffer) [i];
                    buffer [2 * i + 1] = buffer [2 * i];
                }
                audioBuffer  -> putDataIntoBuffer (buffer, samples); //TODO: write in out buffer instead
                if (audioBuffer -> GetRingBufferReadAvailable () > sampleRate / 8)
                    newAudio (sampleRate);
            }
            else
                GR_LOG_DEBUG(d_logger, format("Cannot handle these channels"));

            return samples / 2;
        }
